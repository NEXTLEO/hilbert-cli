#! /usr/bin/env bash
# for emacs: -*-sh-*-

## TODO: add some more description here?

## NOTE: Exit codes may be as follows (see status.sh, others will be updated):
##  - 0: success (no error detected). There maybe warnings
##  - 1: detected error which is not our fault (e.g. network / HW etc): user can try again
##  - 2: error due to wrong usage of scripts (bad arguments) / in config files or some assumption was violated.
##      NOTE: in PEDANTIC mode some non-critical issues may be treated this way.
##  - any other value: something unexpected has happened!

## NOTE: see also http://tldp.org/LDP/abs/html/exitcodes.html
declare -rg TOOL_SH="$0"
declare -rg TOOL="$(basename "${TOOL_SH}")" # script_name=`basename "$0"` # script_name="${script_name%.*}"

declare -g LOGLEVEL=2  # WARNING-LEVEL
declare -g DRY_RUN=""  # NOTE: turn on dry mode (not actual service-runtime action execution) if non-empty
declare -g hibert_station_process_kill_timeout=8

## NOTE: locking following: http://stackoverflow.com/a/1985512 by Przemyslaw Pawelczyk <przemoc@gmail.com>
## NOTE: uses flock from util-linux[-ng]
## TODO(?): evaluate other ways according to http://stackoverflow.com/questions/1715137/the-best-way-to-ensure-only-1-copy-of-bash-script-is-running

## NOTE: usually /var/lock/ is a symbolic link to /run/lock/ => it will be removed in case of a crash! No stale lockfile is possible!
## NOTE: just in case if /run != /var/run the following loop will check them separately:
for d in /var/lock/lockdev /run/lock/lockdev /var/lock /run/lock /var/run /run;
do
    if [[ -w "${d}/" ]]; then
        declare -- LOCKFILE="${d}"
        break
    fi
done

if [[ -n "${LOCKFILE}" && -w "${LOCKFILE}/" ]]; then
    LOCKFILE+="/${TOOL}.lock"
else
    ## NOTE: /tmp/ may not be cleaned up due to reboot... But it is always writeable
    declare -- LOCKFILE="/tmp/_var_lock_${TOOL}.lock"
fi

declare -ir LOCKFD=99

## PRIVATE flock WRAPPER API
function _lock()             { flock "-$1" ${LOCKFD}; }
function _no_more_locking()  { _lock u; _lock xn && rm -f "${LOCKFILE}"; exec 2>&4 1>&3; }
function _prepare_locking()  { eval "exec $LOCKFD>\"$LOCKFILE\""; trap _no_more_locking EXIT; }

## PUBLIC flock WRAPPER API
function exlock_now()        { _lock xn; }  # obtain an exclusive lock immediately or fail
function exlock()            { _lock x; }   # obtain an exclusive lock. wait
function shlock()            { _lock s; }   # obtain a shared lock
function unlock()            { _lock u; }   # drop a lock

exec 3>&1 4>&2
## See also https://www.gnu.org/software/bash/manual/bashref.html#index-signal-handling
## NOTE: SIGKILL and SIGSTOP can not be caught, blocked or ignored.
trap 'exec 2>&4 1>&3 ' SIGHUP SIGINT SIGQUIT SIGPIPE SIGTERM EXIT RETURN
## NOTE: SIGTSTP => bg! ? RETURN ???
exec 2>&1
# 1>log.out

function cmd_start_locking() {
    local pid
    for pid in $(pidof -s "${TOOL}"); do
        if [[ $pid != $$ ]]; then
            ERROR "Process is already running with PID $pid"
            exit 1
        fi
    done

    DEBUG "Starting exclusive (locked) usage of ${TOOL}..."

    # ON START:
    _prepare_locking
    # Simplest example is avoiding running multiple instances of script: `exlock_now || exit 1`
    # Remember! Lock file is removed when one of the scripts exits and it is
    #           the only script holding the lock or lock is not acquired at all.
    local l
    if exlock_now
    then
        l="$(ls -l "${LOCKFILE}" 2>&1)"
        DEBUG "Obtained exclusive lock of [$l]"
    else
        l="$(ls -l "${LOCKFILE}" 2>&1)"
        DEBUG "Lockfile: [$l]"
        ERROR "Another user is already running ${TOOL}: please try again later!"
        exit 2
    fi
    return $?
}

function DEBUG() {
    if [[ $LOGLEVEL -le 0 ]]; then
        echo "DEBUG   [${TOOL}:${FUNCNAME[1]}] $*"
    fi
    return 0
}
function INFO() {
    if [[ $LOGLEVEL -le 1 ]]; then
        echo "INFO    [${TOOL}:${FUNCNAME[1]}] $*"
    fi
    return 0
}
function WARNING() {
    if [[ $LOGLEVEL -le 2 ]]; then
        echo "WARNING [${TOOL}:${FUNCNAME[1]}] $*" 1>&2
    fi
    return 0
}
function ERROR() {
    if [[ $LOGLEVEL -le 3 ]]; then
        echo "ERROR   [${TOOL}:${FUNCNAME[1]}] $*" 1>&1
    fi
    return 1
}

## TODO: read HILBERT_CONFIG_BASEDIR from '~/.hilbert-station' ?
## TODO: use @configs!!!!
export HILBERT_CONFIG_BASEDIR="${HILBERT_CONFIG_BASEDIR:-${HOME}/.config/${TOOL}}"

export HILBERT_CONFIG_DIR="${HILBERT_CONFIG_BASEDIR}/configs"
export HILBERT_CONFIG_FILE="${HILBERT_CONFIG_DIR}/station.cfg"

export HILBERT_STATION_VERSION_ID="\$Id$"

## NOTE: the following is run-time  (docker/docker-compose) specific!

## TODO: FIXME: will be hilbert due to migration!
export COMPOSE_PROJECT_NAME="${COMPOSE_PROJECT_NAME:-hilbert}"
# export COMPOSE_PROJECT_NAME="${COMPOSE_PROJECT_NAME:-dockapp}"

export HILBERT_OGL="${HILBERT_OGL:-/tmp/OGL.tgz}"
declare -rg OGL="$(basename "${HILBERT_OGL}")"

export DOCKER="$(readlink -f "${DOCKER:-$(which docker)}")"
export DOCKER_GC="$(readlink -f "${DOCKER_GC:-$(which docker-gc)}")"
export DOCKER_COMPOSE="$(readlink -f "${HILBERT_CONFIG_BASEDIR}/compose")"

for d in /usr/sbin/shutdown /sbin/shutdown;
do
    if [[ -f "${d}" && -x "${d}" ]]; then
        declare -rg SHUTDOWN="${d}"
        break
    fi
done

if [[ ! -v SHUTDOWN ]]; then
    declare -rg SHUTDOWN=$(which shutdown 2>&1)
fi

## @fn cmd_usage Show CLI usage help
function cmd_usage() {
    cat << EOF
usage: ${TOOL} [-h] [-p] [-V] [-v | -q] subcommand

Hilbert - client part for Linux systems

positional arguments:
 subcommand:
   init [<cfg>]            init station based on given or installed configuration
   list_applications       list of (supported) applications
   list_services           list of background services
   app_change <app_id>     change the currently running top application to specified
   start                   start Hilbert on the system
   stop                    stop Hilbert on the system
   shutdown                shut down the system

optional arguments:
  -h                       show this help message and exit
  -V                       show version info and exit
  -v                       increase verbosity
  -q                       decrease verbosity
  -t                       turn on BASH tracing and verbosity
  -T                       turn off BASH tracing and verbosity
  -d                       turn on dry-run mode
  -D                       turn off dry-run mode

respected environment variables:
  HILBERT_CONFIG_BASEDIR   location of the base configuration directory of ${TOOL}. Default: '~/.config/${TOOL}'
EOF
}

## @fn cmd_native_autodetect Native Auto-detections
function cmd_native_autodetect() {
    ## Docker Engine
    export DOCKER_SOCKET=${DOCKER_SOCKET:-/var/run/docker.sock}
    if [[ -S "${DOCKER_SOCKET}" ]]; then
        export DOCKER_HOST=${DOCKER_HOST:-unix://$DOCKER_SOCKET}
    else
        export DOCKER_HOST=${DOCKER_HOST:-$DOCKER_SOCKET}
    fi

    INFO "DOCKER_HOST: ${DOCKER_HOST}, DOCKER_SOCKET: ${DOCKER_SOCKET}"

    if [[ -z "${HILBERT_XAUTH}" || -z "${DISPLAY}" || -z "${XAUTHORITY}" ]]; then
        local XID="/tmp/x.id"
        ## X11: see http://unix.stackexchange.com/questions/10121/open-a-window-on-a-remote-x-display-why-cannot-open-display
        local N="0"
        # TODO: 1: parse $DISPLAY if set!
        # What about forwarded X11 Displays? e.g. localhost:10.0?
        if [[ -z "${XAUTHORITY}" ]]; then  # TODO: Cleanup the following mess!!!
            if [[ -r "$XID" ]]; then
                N=$(grep 'DISPLAY_NUM:' "$XID" | tail -n 1 | sed s@DISPLAY_NUM:@@g)
            fi

            if [[ -f "/tmp/.X${N}-lock" ]]; then
                export DISPLAY=":${N}"
                # TODO: make sure we can use it!
            else
                # TODO: FIXME: Quick and dirty hack for now...
                export DISPLAY=:0

                if [[ -r "${HOME}/.Xauthority" ]]; then
                    export XAUTHORITY="${HOME}/.Xauthority"
                elif [[ -r "/run/user/${UID}/gdm/Xauthority" ]]; then
                    export XAUTHORITY="/run/user/${UID}/gdm/Xauthority}"
                    # Any other variants?
                fi
            fi
        else
            if [[ -z "${DISPLAY}" ]]; then
                WARNING "Wrong environment: missing 'DISPLAY' with set 'XAUTHORITY'!"
            fi

            # TODO: FIXME: write "DISPLAY_NUM${DISPLAY}" & XAUTHORITY into ${XID}!?
        fi

        # loop through display number 0 ... 100
        # until free display number is found
        while [[ -z "${DISPLAY}" && "${N}" -le 100 ]]
        do
            if [[ -f "/tmp/.X${N}-lock" ]]; then
                # TODO: check whether we can use it!
                export DISPLAY=":${N}"  # XAUTHORITY?
                break;
            fi;
            N=$((N+1))
        done

        export HILBERT_XAUTH="${HILBERT_XAUTH:-/tmp/.docker.xauth}"
        # TODO: HILBERT_DISPLAY?

        if [[ -f "${XAUTHORITY}" ]]; then
        # :  echo "DISPLAY: '${DISPLAY}', XAUTHORITY: '${XAUTHORITY}' -> '${HILBERT_XAUTH}'"
        #   [ ! -f "${XAUTH}" ] && touch "${XAUTH}"
            (xauth nlist "${DISPLAY}" | sed -e 's/^..../ffff/' | sort | uniq | xauth -f "${HILBERT_XAUTH}" nmerge - ) 1> /dev/null 2>&1
        #   [ ! -s "${HILBERT_XAUTH}" ] && echo "WARNING: something is wrong with '${XAUTH}': `ls -al ${XAUTH}`"
        fi

        if [[ ! -f "${HILBERT_XAUTH}" ]]; then
            WARNING "Missing X cookie: ${HILBERT_XAUTH}"
        fi

        ## Let root use our current X11... https://wiki.archlinux.org/index.php/Running_X_apps_as_root ?
        (xhost +; xhost "+si:localuser:${USER}"; xhost +si:localuser:root) 1> /dev/null 2>&1 # xhost + localhost;
    fi

   INFO "DISPLAY: ${DISPLAY}, XAUTHORITY: ${XAUTHORITY}, HILBERT_XAUTH: ${HILBERT_XAUTH}"

   ## Pulse Audio
   export PULSE_SERVER=${PULSE_SERVER:-/run/user/${UID}/pulse/native}
   export PULSE_COOKIE=${PULSE_COOKIE:-${HOME}/.config/pulse/cookie}
   INFO "PULSE_SERVER: ${PULSE_SERVER}, PULSE_COOKIE: ${PULSE_COOKIE}"

   # Detect HILBERT_ALSA_CARD??
   return 0
}

## @fn cmd_info Show Station System INFO & Configuration
function cmd_info() {
    cat << EOF
This tool:   [${TOOL}: ${TOOL_SH}: $(ls -l "$(readlink -f "${TOOL_SH}")" 2>&1)]
PID:         [$$]
Lockfile:    [${LOCKFILE}: $(ls -l "$(readlink -f "${LOCKFILE}")" 2>&1)]

Config Base: [${HILBERT_CONFIG_BASEDIR}]
Config Dir:  [${HILBERT_CONFIG_DIR}: $(readlink -f "${HILBERT_CONFIG_DIR}" 2>&1)]
Config File: [${HILBERT_CONFIG_FILE}: $(readlink -f "${HILBERT_CONFIG_FILE}" 2>&1)]
All Configs: [$(sh -c "cd ${HILBERT_CONFIG_DIR}/ && ls * | xargs" 2>&1)]

DRY_RUN:     [${DRY_RUN}]
LOGLEVEL:    [${LOGLEVEL}]

OGL:         [${HILBERT_CONFIG_BASEDIR}/${OGL}: $(ls -l "${HILBERT_CONFIG_BASEDIR}/${OGL}" 2>&1)]
HILBERT_OGL: [${HILBERT_OGL}: $(ls -l "$(readlink -f "${HILBERT_OGL}")" 2>&1)]

DOCKER:      [${DOCKER}: $(${DOCKER} --version 2>&1)]
DOCKER_GC:   [${DOCKER_GC}: $(ls -l "${DOCKER_GC}" 2>&1)]

DOCKER_COMPOSE:       [${DOCKER_COMPOSE}: $(${DOCKER_COMPOSE} --version 2>&1)]
COMPOSE_PROJECT_NAME: [${COMPOSE_PROJECT_NAME}]

HOME:        [${HOME}]
PWD:         [${PWD}]
PATH:        [${PATH}]

date:        [$(date)]
uname:       [$(uname -a)]
hostname:    [$(hostname), $(hostname -I)]
id:          [$(id)]

SHUTDOWN:    [${SHUTDOWN}: $(ls -l "${SHUTDOWN}")]
PTMX:        [$(ls -l /dev/pts/ptmx 2>&1)]

EOF
    echo "Current Station Configuration [${HILBERT_CONFIG_FILE}]:
"
    cat "${HILBERT_CONFIG_FILE}"  # TODO: indent the file contents for pretty-printing?
    echo ""

    local H=($(${DOCKER} ps -qa --filter "label=com.docker.compose.project=${COMPOSE_PROJECT_NAME}" 2>/dev/null))
    if [[ -n "${H[*]}" ]]; then
        echo "
Previously started Hilbert's services/applications found:
"
        ${DOCKER} ps -a --filter "label=com.docker.compose.project=${COMPOSE_PROJECT_NAME}"
    else
        INFO "No previously started services detected!"
    fi

    cmd_native_autodetect
    return 0
}

## @fn cmd_version Script name + version
## NOTE: will show more info for debugging
function cmd_version() {
    cat << EOF
${TOOL} Version ID: [${HILBERT_STATION_VERSION_ID}]
EOF
    if [[ $LOGLEVEL -le 1 ]]; then
        cmd_info
    fi
    return 0
}

declare -rg INPUT_ARGS=($@)

# NOTE: Custom argument/option handling only using 'getopts'!
while getopts ":hqtTdDvV" opt; do   # NOTE: removed 'p' for now
    case ${opt} in
    h )
        cmd_usage
        exit 0
        ;;
    V )
        cmd_version "$@"
        exit 0
        ;;
    t )
        # NOTE: see also http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_03.html
        DEBUG "Turning on tracing of bash command execution + verbosity..."
        set -v
        set -x
        ;;
    T )
        # NOTE: see also http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_03.html
        DEBUG "Turning off tracing of bash command execution + verbosity..."
        set +v
        set +x
        ;;
    v )
        DEBUG "Increase verbosity..."
        LOGLEVEL=$((LOGLEVEL-1))
        ;;
    q )
        DEBUG "Decrease verbosity..."
        LOGLEVEL=$((LOGLEVEL+1))
        ;;
    d )
        DEBUG "Turning on dry-run mode..."
        DRY_RUN="Dry-Run-Mode"
        ;;
    D )
        DEBUG "Turning off dry-run mode..."
        DRY_RUN=""
        ;;
    \? )
        ERROR "Invalid Option: -$OPTARG"
        exit 1
        ;;
    esac
done

DEBUG "Input args: [${INPUT_ARGS[@]}]"

if [[ ! -d "${HILBERT_CONFIG_BASEDIR}" ]]; then
    DEBUG "Base Configuration base directory '${HILBERT_CONFIG_BASEDIR}' is missing!"
    mkdir -p "${HILBERT_CONFIG_BASEDIR}"
fi

if [[ ! -r "${HILBERT_CONFIG_BASEDIR}" ]]; then
    DEBUG "Base Configuration directory '${HILBERT_CONFIG_BASEDIR}' is unreadable!"
    chmod u+rwx "${HILBERT_CONFIG_BASEDIR}"
fi

if [[ ! -d "${HILBERT_CONFIG_BASEDIR}" ]]; then
    ERROR "Base Configuration directory '${HILBERT_CONFIG_BASEDIR}' is missing!"
    exit 1
fi

if [[ ! -r "${HILBERT_CONFIG_BASEDIR}" ]]; then
    ERROR "Configuration directory '${HILBERT_CONFIG_BASEDIR}' is unreadable!"
    exit 1
fi

DEBUG "Base Configuration directory '${HILBERT_CONFIG_BASEDIR}' exists and is readable..."

if [[ ! -d "${HILBERT_CONFIG_DIR}" ]]; then
    DEBUG "Configuration directory '${HILBERT_CONFIG_DIR}' is initialized yet!"
fi

if [[ ! -r "${HILBERT_CONFIG_FILE}" ]]; then
    WARNING "Station Configuration file '${HILBERT_CONFIG_FILE}' is unreadable!"
#    exit 1
else
    DEBUG "Station Configuration file '${HILBERT_CONFIG_FILE}' exists and is readable..."
fi


## NOTE: Global knowledge about supported services/applications:
declare -r _type_field='type'
declare -rA _type_specs=( ['compose']='file ref' )

function _service_get_type_spec() {
    ## NOTE: ServiceType: 'compose' etc...
    local f="${_type_specs[$*]}"
    echo "$f"
    if [[ -z "$f" ]]; then
        return 2
    fi
    return 0
}

function _service_get_type() {
    _service_get_field "$@" "${_type_field}"
    return $?
}

function _service_get_field() {
    local k="$1:$2"
    echo "${hilbert_station_services_and_applications[$k]}"
    return $?
}


function _service_get_info() {
    ## NOTE: Application ID:
    local s="$*"
    local t
    local f
    t=$(_service_get_type "$s")
    if [[ $? -ne 0 ]]; then
        return $?
    fi

    f=$(_service_get_type_spec "$t")
    if [[ $? -ne 0 ]]; then
        return $?
    fi

    local ret="$t"
    local k
    for k in $f; do
        local data
        data=$(_service_get_field "$s" "$k")
        if [[ $? -ne 0 ]]; then
            return $?
        fi
        ret+=", $k: '$data'"
    done

    echo "$ret"
    return 0
}


function cmd_install_station_config() {
    local arg="$*"
    local base
    local new_cfg_dir

    if [[ -z "${arg}" ]]; then
        ERROR "Wrong argument '${arg}'!"
        cmd_usage
        exit 1
    fi

    base=$(basename "${arg}")

    new_cfg_dir=$(mktemp -u -d --tmpdir="${HILBERT_CONFIG_BASEDIR}" "$base.XXXXXXXXXX")
    DEBUG "NOTE: new config is '${base}' => new_cfg_dir: '${new_cfg_dir}'"

    # TODO: what about further resources? Maybe a .tar.gz and unpack it into ${new_cfg_dir}? rsync?!
    if [[ -d "${arg}" ]]; then

        WARNING "New configuration directory: '${arg}'"  # is not yet fully supported!!!?

        if [[ ! -r "${arg}/station.cfg" ]]; then
            ERROR "Station configuration file '${arg}/station.cfg' is not readable or missing!"
            cmd_usage
            exit 1
        fi

        # NOTE: take over the deployed station configurations
        DEBUG "Moving ${arg} => ${new_cfg_dir}..."
        mv "${arg}" "${new_cfg_dir}"

    elif [[ -r "${arg}" ]]; then

        # NOTE: New station's configuration file
        # TODO: make sure there is no such dir yet!

        WARNING "Deprecated init method!!!"
        INFO "Initializing with a single station-config file: [${arg}]... Unique base name: $base"

        # NOTE: take over the deployed station configuration file!
        DEBUG "Moving ${arg} => ${new_cfg_dir}/station.cfg"

        mkdir -p "${new_cfg_dir}"  ## TODO: add mode?
        mv "${arg}" "${new_cfg_dir}/station.cfg"

        # NOTE: the rest of resources must be installed manually by hand:
        ln -s '../docker-compose.yml' "${new_cfg_dir}/docker-compose.yml"
    else
        ERROR "Cannot Install configuration specified by '${arg}'!"
        cmd_usage
        exit 1
    fi


    if [[ -L "${HILBERT_CONFIG_DIR}" ]]; then
        DEBUG "${HILBERT_CONFIG_DIR} -> $(readlink -f "${HILBERT_CONFIG_DIR}")"
        # TODO: remove older config?
        unlink "${HILBERT_CONFIG_DIR}"
    elif [[ -d "${HILBERT_CONFIG_DIR}" ]]; then
        ERROR "Directory ${HILBERT_CONFIG_DIR} exists and it is not a link!"
        exit 2
    fi

    ## NOTE: atomic configuration update!
    ## NOTE: full path in symbolic link => may interfere when volume-mounted...
    ln -sf "$(basename "${new_cfg_dir}")" "${HILBERT_CONFIG_DIR}"

    if [[ ! -L "${HILBERT_CONFIG_DIR}" ]]; then
        ERROR "${HILBERT_CONFIG_DIR} is not a link!"
        exit 2
    fi

    ## TODO: FIXME: All deployed docker-compose.yml files should be previously pre-peared & simplified!
    return 0
}


## @fn cmd_read_configuration
function cmd_read_configuration() {
    if [[ ! -r "${HILBERT_CONFIG_FILE}" ]]; then
        ERROR "Configuration file '${HILBERT_CONFIG_FILE}' is not readable ($(ls -la ${HILBERT_CONFIG_FILE})!"
        exit 1
    fi

    # NOTE: try to read/check station configuration only once (if it is valid):
    declare -p "hilbert_station_services_and_applications" 1>>/dev/null 2>&1
    if [[ $? -eq 0 ]]; then
        DEBUG "Configuration file has been loaded already!"
        return 0
    fi

    declare -p "hilbert_station_profile_services" 1>>/dev/null 2>&1
    if [[ $? -eq 0 ]]; then
        DEBUG "Configuration file has been loaded already!"
        return 0
    fi

    declare -p "hilbert_station_profile_services" 1>>/dev/null 2>&1
    if [[ $? -eq 0 ]]; then
        DEBUG "Configuration file has been loaded already!"
        return 0
    fi

    source "${HILBERT_CONFIG_FILE}"  # TODO: FIXME: only pass declare ... key="...value..."!?
    local _ret=$?

    declare -p "hilbert_station_services_and_applications" 1>>/dev/null 2>&1
    if [[ $? -ne 0 ]]; then
        ERROR "Wrong local configuration file: '${HILBERT_CONFIG_FILE}'! NOTE: it should set at least 'hilbert_station_services_and_applications'!"
        exit 1
    fi

    declare -p "hilbert_station_profile_services" 1>>/dev/null 2>&1
    if [[ $? -ne 0 ]]; then
        DEBUG "Strange local configuration file: '${HILBERT_CONFIG_FILE}': 'hilbert_station_profile_services' is not set!"
    fi

    declare -p "hilbert_station_compatible_applications" 1>>/dev/null 2>&1
    if [[ $? -ne 0 ]]; then
        DEBUG "Strange local configuration file: '${HILBERT_CONFIG_FILE}': 'hilbert_station_compatible_applications' is not set!"
    fi

    return ${_ret}
}

## @fn cmd_init
## @param [cfg] (optional)
function cmd_init() {
    local arg="$*"

    if [[ ! -w "/dev/pts/ptmx" ]]; then
        if [[ -n "${DRY_RUN}" ]]; then
            echo "[${DRY_RUN}] Running: [chmod a+rw /dev/pts/ptmx]..."
        else
            DEBUG "Trying to fix '/dev/pts/ptmx'-permissions:"

            chmod a+rw /dev/pts/ptmx 1>/dev/null 2>&1 || \
            sudo -n -P chmod a+rw /dev/pts/ptmx 1>/dev/null 2>&1 || \
            WARNING "Could not run: 'chmod a+rw /dev/pts/ptmx'!"
        fi
    fi

    cmd_native_autodetect
    if [[ -n "${arg}" && -r "${arg}" ]]; then
        cmd_install_station_config "${arg}"
    fi

    local s

    cmd_read_configuration
    if [[ ${#hilbert_station_profile_services[@]} -ne 0 ]]; then
        for s in "${hilbert_station_profile_services[@]}"; do
            DEBUG "Init [$s]"
            cmd_init_service "${s}"
        done
    fi

    if [[ ${#hilbert_station_compatible_applications[@]} -ne 0 ]]; then
        for s in "${hilbert_station_compatible_applications[@]}"; do
            DEBUG "Init [$s]"
            cmd_init_service "${s}"
        done
    fi

    ## TODO: hilbert_cleanup==true? =>
    if [[ -n "${DOCKER_GC}" ]]; then
        if hash "${DOCKER_GC}" 2>/dev/null; then
            if [[ -z "${DRY_RUN}" ]]; then
                echo "[${DRY_RUN}] Running: [${DOCKER_GC}]: "
#                ${DOCKER_GC}  # NOTE: actually run this in production!
            else
                echo "Running: [${DOCKER_GC}]"
            fi
        fi
    fi

    if [[ ! -r "${HILBERT_CONFIG_BASEDIR}/${OGL}" ]]; then
        INFO "Missing/unreadable '${HILBERT_CONFIG_BASEDIR}/${OGL}'! Please regenerate it for OpenGL apps!"
    fi

    return $?
}

## @fn cmd_app_change
function cmd_app_change() {
    ## NOTE: Application ID:
    local arg="$*"

    cmd_native_autodetect

    if [[ -z ${arg} ]]; then
        ERROR "Wrong argument '${arg}'!"
        cmd_usage
        exit 1
    fi

    cmd_read_configuration

    cmd_detect_top_application
    if [[ $? -ne 0 ]]; then
        WARNING "Could not properly detect the current top application!"
        if [[ -n "${current_top_application_id}" ]]; then
            WARNING "Trying to stop (all) found top apps: ${current_top_application_id}..."
            cmd_docker_stop "${current_top_application_id}"
        fi
    else
        if [[ "${APP_ID}" != "$arg" ]]; then
            cmd_stop_service "${APP_ID}"
        else
            cmd_stop_service "${APP_ID}"  #  cmd_restart_service "${APP_ID}" ; return 0 # Same Application ID => Same Env.Vars??? :-(
        fi
    fi

    cmd_start_service "$arg"
    return $?
}

function cmd_start_service() {
    local arg="$*"

    if [[ -z ${arg} ]]; then
        ERROR "Wrong argument '${arg}'!"
        cmd_usage
        exit 1
    fi

    cmd_read_configuration

    local t
    t="$(_service_get_type "${arg}")"

    if [[ "x$t" != "xcompose" ]]; then
        ERROR "Unsupported application type of service/application '${arg}': '$t'"
        exit 1
    fi

    ## NOTE: auto_detections are common for any type...
    local HILBERT_APPLICATION_AD
    HILBERT_APPLICATION_AD="$(_service_get_field "$arg" "auto_detections")"
    if [[ -n "${HILBERT_APPLICATION_AD}" ]]; then
        DEBUG "Running Auto-Detections: [${HILBERT_APPLICATION_AD}]..."
        eval "${HILBERT_APPLICATION_AD}"
    fi

    DEBUG "Starting service/application via docker-compose: ${arg}..."
    cmd_compose_start "${arg}"

    return $?
}

function cmd_init_service() {
    ## NOTE: Application/Service ID
    local arg="$*"

    if [[ -z ${arg} ]]; then
        ERROR "Wrong argument '${arg}'!"
        cmd_usage
        exit 1
    fi

    cmd_read_configuration

    local t
    t="$(_service_get_type "${arg}")"

    if [[ ! "x$t" = "xcompose" ]]; then
        ERROR "Wrong or unsupported application: '${arg}' (type: '$t')"
        exit 1
    fi

    ## NOTE: auto_detections are common for any type...
    local HILBERT_APPLICATION_AD
    HILBERT_APPLICATION_AD="$(_service_get_field "$arg" "auto_detections")"
    if [[ -n "${HILBERT_APPLICATION_AD}" ]]; then
        DEBUG "Running Auto-Detections: [${HILBERT_APPLICATION_AD}]..."
        eval "${HILBERT_APPLICATION_AD}"
    fi

    DEBUG "Initializing/preparing service/application via docker-compose: ${arg}..."
    cmd_compose_init "${arg}"

    return $?
}

## @fn cmd_restart_service  Deprecated!!!! TO BE REMOVED!?
## @param arg ApplicationID
function cmd_restart_service() {
    ## NOTE: Application ID
    local arg="$*"

    if [[ -z ${arg} ]]; then
        ERROR "Wrong argument '${arg}'!"
        cmd_usage
        exit 1
    fi

    cmd_read_configuration

    local t
    t="$(_service_get_type "${arg}")"

    if [[ ! "x$t" = "xcompose" ]]; then
        ERROR "Wrong or unsupported application: '${arg}' (type: '$t')"
        exit 1
    fi

    ## NOTE: auto_detections are common for any type...
    local HILBERT_APPLICATION_AD
    HILBERT_APPLICATION_AD="$(_service_get_field "$arg" "auto_detections")"
    if [[ -n "${HILBERT_APPLICATION_AD}" ]]; then
        DEBUG "Running Auto-Detections: [${HILBERT_APPLICATION_AD}]..."
        eval "${HILBERT_APPLICATION_AD}"
    fi

    DEBUG "Restarting service/application via docker-compose: ${arg}..."
    cmd_compose_restart "${arg}"

    return $?
}

## @fn cmd_stop_service
## @param arg ApplicationID
function cmd_stop_service() {
    ## NOTE: Application ID
    local arg="$*"

    if [[ -z "${arg}" ]]; then
        ERROR "Wrong argument '${arg}'!"
        cmd_usage
        exit 1
    fi

    cmd_read_configuration

    local t
    t="$(_service_get_type "${arg}")"

    if [[ ! "x$t" = "xcompose" ]]; then
        ERROR "Wrong or unsupported application: '${arg}' (type: '$t')"
        exit 1
    fi

    DEBUG "Stopping service/application via docker-compose: ${arg}..."
    cmd_compose_stop "${arg}"

    return 0
}

function cmd_compose_start() {
    ## NOTE: Application ID
    local arg="$*"

    local HILBERT_APPLICATION_FILE
    local HILBERT_APPLICATION_REF
    HILBERT_APPLICATION_FILE="$(_service_get_field "$arg" "file")"
    HILBERT_APPLICATION_REF="$(_service_get_field "$arg" "ref")"

    export HILBERT_APPLICATION_ID="$arg"  # NOTE: To be set as env. variable APP_ID within container...

    ## NOTE: Simplify COMPOSE_FILE -> launch!
    local PLAIN_COMPOSE_FILE="${HILBERT_CONFIG_DIR}/cached_for_${HILBERT_APPLICATION_ID}.${HILBERT_APPLICATION_FILE:-docker-compose.yml}"
    if [[ -r ${PLAIN_COMPOSE_FILE} ]]; then
        export COMPOSE_FILE="${PLAIN_COMPOSE_FILE}"
    else
        export COMPOSE_FILE="${HILBERT_APPLICATION_FILE:-docker-compose.yml}"  # Default value
    fi

    DEBUG "Starting service/application: ${HILBERT_APPLICATION_ID} (${HILBERT_APPLICATION_REF} from ${COMPOSE_FILE})..."

    cmd_docker_compose up -d "${HILBERT_APPLICATION_REF}"

    unset -v HILBERT_APPLICATION_ID COMPOSE_FILE

    return 0
}


function cmd_compose_init() {
    ## NOTE: Application/Service ID (of compose type)
    local arg="$*"

    local HILBERT_APPLICATION_FILE
    local HILBERT_APPLICATION_REF
    HILBERT_APPLICATION_FILE="$(_service_get_field "$arg" "file")"
    HILBERT_APPLICATION_REF="$(_service_get_field "$arg" "ref")"

    ## TODO: Simplify COMPOSE_FILE -> launch!
    export COMPOSE_FILE="${HILBERT_APPLICATION_FILE:-docker-compose.yml}"  # Default value
    export HILBERT_APPLICATION_ID="$arg"  # NOTE: To be set as env. variable APP_ID within container...

    local PLAIN_COMPOSE_FILE="${HILBERT_CONFIG_DIR}/cached_for_${HILBERT_APPLICATION_ID}.${HILBERT_APPLICATION_FILE:-docker-compose.yml}"
    DEBUG "Trying to simplify: '${COMPOSE_FILE}' -> '${PLAIN_COMPOSE_FILE}': "
    cmd_docker_compose config > "${PLAIN_COMPOSE_FILE}"
    ## NOTE: running config once should be enough... ?
    # "HB_URL=${HILBERT_HEARTBEAT_URL:-http://127.0.0.1:${HILBERT_HEARTBEAT_PORT:-8888}}" :-(

    if [[ $? -eq 0 ]]; then  # && [[ -z "${DRY_RUN}" ]] ???
#        export COMPOSE_FILE="${PLAIN_COMPOSE_FILE}~"
#        cmd_docker_compose config > "${PLAIN_COMPOSE_FILE}"
#        rm "${COMPOSE_FILE}"
        export COMPOSE_FILE="${PLAIN_COMPOSE_FILE}"
    fi
    #### TODO: all provided docker-compose.yml files should be pre-processed&simplified!...

    DEBUG "Initializing/preparing service/application: ${HILBERT_APPLICATION_ID} (${HILBERT_APPLICATION_REF} from ${COMPOSE_FILE})..."
    cmd_docker_compose pull --ignore-pull-failures "${HILBERT_APPLICATION_REF}"
    ret=$?

    unset -v HILBERT_APPLICATION_ID COMPOSE_FILE

    return $ret
}


function cmd_compose_restart() {
    ## NOTE: Application ID
    local arg="$*"

    local HILBERT_APPLICATION_FILE
    local HILBERT_APPLICATION_REF
    HILBERT_APPLICATION_FILE="$(_service_get_field "$arg" "file")"
    HILBERT_APPLICATION_REF="$(_service_get_field "$arg" "ref")"

    export HILBERT_APPLICATION_ID="$arg"  # NOTE: To be set as env. variable APP_ID within container...

    ## NOTE: Simplify COMPOSE_FILE -> launch!
    local PLAIN_COMPOSE_FILE="${HILBERT_CONFIG_DIR}/cached_for_${HILBERT_APPLICATION_ID}.${HILBERT_APPLICATION_FILE:-docker-compose.yml}"
    if [[ -r ${PLAIN_COMPOSE_FILE} ]]; then
        export COMPOSE_FILE="${PLAIN_COMPOSE_FILE}"
    else
        export COMPOSE_FILE="${HILBERT_APPLICATION_FILE:-docker-compose.yml}"  # Default value
    fi

    DEBUG "Restarting service/application: ${HILBERT_APPLICATION_ID} (${HILBERT_APPLICATION_REF} from ${COMPOSE_FILE})..."
    cmd_docker_compose restart -t 3 "${HILBERT_APPLICATION_REF}"
    ret=$?

    unset -v HILBERT_APPLICATION_ID COMPOSE_FILE

    return $ret
}

function cmd_compose_stop() {
    local arg="$*"  # Application ID

    local HILBERT_APPLICATION_FILE
    local HILBERT_APPLICATION_REF
    HILBERT_APPLICATION_FILE="$(_service_get_field "$arg" "file")"
    HILBERT_APPLICATION_REF="$(_service_get_field "$arg" "ref")"

    export HILBERT_APPLICATION_ID="$arg"  # NOTE: To be set as env. variable APP_ID within container...

    ## NOTE: Simplify COMPOSE_FILE -> launch!
    local PLAIN_COMPOSE_FILE="${HILBERT_CONFIG_DIR}/cached_for_${HILBERT_APPLICATION_ID}.${HILBERT_APPLICATION_FILE:-docker-compose.yml}"
    if [[ -r ${PLAIN_COMPOSE_FILE} ]]; then
        export COMPOSE_FILE="${PLAIN_COMPOSE_FILE}"
    else
        export COMPOSE_FILE="${HILBERT_APPLICATION_FILE:-docker-compose.yml}"  # Default value
    fi

    DEBUG "Stopping service/application: ${HILBERT_APPLICATION_ID} (${HILBERT_APPLICATION_REF} from ${COMPOSE_FILE})..."

    local d="${HILBERT_APPLICATION_REF}"

    DEBUG "Stopping/Killing/Removing service '$d' using docker-compose..."

    cmd_docker_compose kill -s SIGINT "$d" && sleep "${hibert_station_process_kill_timeout}"
#    cmd_docker_compose kill -s SIGTERM "$d"  #    cmd_docker_compose kill -s SIGKILL "$d"
    cmd_docker_compose stop -t "${hibert_station_process_kill_timeout}" "$d"
    cmd_docker_compose rm -vf "$d"
    cmd_docker_compose rm -vf "$d"  # NOTE: to remove "dead" left-over containers!
#    (cmd_docker_compose rm "$d" || cmd_docker_compose rm -vf "$d")

    unset -v HILBERT_APPLICATION_ID COMPOSE_FILE

    return 0
}

function cmd_docker_stop() {
    local d=$*
    DEBUG "Stopping/Killing/Removing service '$d' using '${DOCKER}'..."

    cmd_docker kill -s SIGINT $d && sleep "${hibert_station_process_kill_timeout}"
#    cmd_docker kill -s SIGTERM $d #    cmd_docker kill -s SIGKILL $d
    cmd_docker stop -t "${hibert_station_process_kill_timeout}" $d
    cmd_docker rm -vf $d
    cmd_docker rm -vf $d  # NOTE: to remove "dead" left-over containers!
#    (cmd_docker rm $d || cmd_docker rm -vf $d)

    return $?
}

function cmd_docker_compose() {
    if [[ -n "${DRY_RUN}" ]]; then
        echo "[${DRY_RUN}] Running: [${DOCKER_COMPOSE} --skip-hostname-check $*]"
        return 0
    fi

    local S="${PWD}"

    cd "${HILBERT_CONFIG_DIR}"

    if [[ ! -r "${COMPOSE_FILE:-docker-compose.yml}" ]]; then
        ERROR "COMPOSE_FILE ('${PWD}: ${COMPOSE_FILE:-docker-compose.yml}') is missing or unreadable!"
        cd "${S}"
        exit 2
    fi

    #### TODO: all provided docker-compose.yml files should be pre-processed&simplified!
#    ${DOCKER_COMPOSE} config > "~docker-compose.yml~"
#    local OLD="${COMPOSE_FILE}"
#    export COMPOSE_FILE="~docker-compose.yml~"
#    ${DOCKER_COMPOSE} config > "~~docker-compose.yml~~"
#    rm "${COMPOSE_FILE}"
#    export COMPOSE_FILE="~~docker-compose.yml~~"



    ## Actually run docker-compose
    # --debug / --verbose?
    ${DOCKER_COMPOSE} --skip-hostname-check $@
    local ret=$?

    if [[ $LOGLEVEL -le "-1" ]]; then
        ${DOCKER} ps -a
    fi

    if [[ $ret -ne 0 ]]; then
        ERROR "Could not run '${DOCKER_COMPOSE} --skip-hostname-check $*' in '${PWD}' with '${COMPOSE_FILE:-docker-compose.yml}'!"
        exit 1
    fi

    cd "${S}"
    return 0
}

function cmd_docker() {
    if [[ -n "${DRY_RUN}" ]]; then
        echo "[${DRY_RUN}] Running: [${DOCKER} $*]"
        return 0
    fi

    if [[ $LOGLEVEL -le "0" ]]; then
        ${DOCKER} --debug --log-level=debug $@
    else
        ${DOCKER} $@
    fi
    local ret=$?

    if [[ $LOGLEVEL -le "-1" ]]; then
        ${DOCKER} ps -a
    fi

    if [[ $ret -ne 0 ]]; then
        WARNING "Could not run '${DOCKER} [?--debug --log-level=debug?] $*' in '${PWD}'!"
        ## exit 1
    fi

    return $ret
}


#function cmd_docker_pause() {
#    local d=$*
#    DEBUG "Pause service/application '$d' using '${DOCKER}'..."
#
#    cmd_docker pause $d
#    return $?
#}

## NOTE: side effects:
##    Container IDs: current_bg_servce_ids, current_top_application_id
##    Hilbert Application ID: APP_ID, DC reference: current_top_application (unknown docker-compose.yml!)
function cmd_detect_top_application() {
    # TODO: FIXME: can only detect the DC's service name - not Application ID!!!
    # NOTE: cannot attach a label in runtime to docker-compose service :-(
    declare -rg current_bg_servce_ids=$(${DOCKER} ps -a -q --filter "label=is_top_app=0" --filter "label=com.docker.compose.project=${COMPOSE_PROJECT_NAME}" 2>/dev/null | xargs --no-run-if-empty)

    local TOP=($(${DOCKER} ps -a -q --filter "label=is_top_app=1" \
               --filter "label=com.docker.compose.project=${COMPOSE_PROJECT_NAME}" 2>/dev/null ))

    if [[ $? -ne 0 ]]; then
        ERROR "Could not query Docker Engine via ${DOCKER}!"
        exit 1
    fi

    local N=${#TOP[@]}
    declare -rg current_top_application_id="${TOP[@]}"

    if [[ $N -eq 0 ]]; then
        WARNING "Found no top application(s)!"
        return 2
    fi

    ## NOTE: By design there must be a single top (GUI) application!
    if [[ $N -ne 1 ]]; then
        WARNING "Found $N top applications: [${current_top_application_id}]!"
        return 2
    fi

    local SV
    SV=$(${DOCKER} inspect --format='{{index .Config.Labels "com.docker.compose.service" }}' "${current_top_application_id}" 2>/dev/null)
    if [[ $? -ne 0 ]]; then
        ERROR "Could not inspect container '${current_top_application_id}'"
        exit 1
    fi

    # NOTE: set "Env APP_ID=' to Application ID!
    declare -gr APP_ID=$(${DOCKER} inspect --format='{{index .Config.Env }}' "${current_top_application_id}" 2>/dev/null | sed -e 's@^.*APP_ID=@@g' -e 's@ .*$@@g')
    if [[ $? -ne 0 ]]; then
        ERROR "Could not inspect container '${current_top_application_id}' using ${DOCKER}"
        exit 1
    fi

    DEBUG "Found $N top application '${current_top_application_id}': ${SV} / APP_ID: ${APP_ID}"
    declare -gr current_top_application="${SV}"
    return 0
}

## @fn cmd_list_applications List Applications
function cmd_list_applications() {
    local data

    cmd_read_configuration

    if [[ -n "${hilbert_station_compatible_applications[@]}" ]]; then
        echo "Aplications compatible with this station: "
        for app in "${hilbert_station_compatible_applications[@]}"; do
            data="$(_service_get_info "${app}")"
            if [[ $? -ne 0 ]]; then
                ERROR "Wrong Application ID: '${app}'"
            else
                echo " - ${app} [$data]"
            fi
        done
    else
        echo "No application are to be run on this station... this must be a server..!"
    fi

    if [[ -n "${hilbert_station_default_application}" ]]; then
        ## NOTE: check whether ${hilbert_station_default_application} is a valid ID:
        data="$(_service_get_info "${hilbert_station_default_application}")"
        if [[ $? -ne 0 ]]; then
            ERROR "Wrong Application ID: '${hilbert_station_default_application}'"
        else
            echo "Default application: ${hilbert_station_default_application} [$data]"
        fi
    else
        echo "No default application: is this a server?!"
    fi

    cmd_detect_top_application
    if [[ $? -ne 0 ]]; then
        INFO "Could not properly detect previously started Hilbert's application!"
        if [[ -n "${current_top_application_id}" ]]; then
            echo "Previously started Hilbert's applications detected: "
            ${DOCKER} ps -a --filter "label=is_top_app=1" --filter "label=com.docker.compose.project=${COMPOSE_PROJECT_NAME}"
        else
            echo "No previously started applications detected!"
        fi
    else
        echo "Previously started Hilbert's application(s) detected: '${APP_ID}' (ref: '${current_top_application}', id: '${current_top_application_id}')"
    fi

    return 0
}

## @fn cmd_list_services List Services
function cmd_list_services() {
    cmd_read_configuration

    if [[ -n "${hilbert_station_profile_services[@]}" ]]; then
        echo "Background services according to the station profile: "
        for sv in "${hilbert_station_profile_services[@]}"; do
            local data
            data="$(_service_get_info "${sv}")"
            if [[ $? -ne 0 ]]; then
                ERROR "Wrong Service ID: '${sv}'"
            else
                echo " - ${sv} [$data]"
            fi
        done
    else
        echo "No services will be running on this station!"
    fi

    local BG
    BG=($(${DOCKER} ps -qa --filter "label=is_top_app=0" --filter "label=com.docker.compose.project=${COMPOSE_PROJECT_NAME}" 2>/dev/null))
    if [[ -n "${BG[*]}" ]]; then
        echo "Previously started Hilbert's services detected: "
        ${DOCKER} ps -a --filter "label=is_top_app=0" --filter "label=com.docker.compose.project=${COMPOSE_PROJECT_NAME}"
    else
        echo "No previously started services detected!"
    fi

    return 0
}

## @fn cmd_start (re)start services and top application
function cmd_start() {
    cmd_native_autodetect
    cmd_read_configuration
    cmd_detect_top_application
    if [[ -z "${current_top_application_id}" && -z "${current_bg_servce_ids}" ]]; then
        DEBUG "OK: no applications or services are currently running. Clean reboot!"
    else
        WARNING "Crash or multiple start detected: "
        ${DOCKER} ps -a --filter "label=com.docker.compose.project=${COMPOSE_PROJECT_NAME}"

        if [[ -n "${current_bg_servce_ids}" ]]; then
            WARNING "Previously started Hilbert's services detected: "
            ${DOCKER} ps -a --filter "label=is_top_app=0" --filter "label=com.docker.compose.project=${COMPOSE_PROJECT_NAME}"
        else
            DEBUG "No previously started services are currently detected"
        fi

        if [[ -n "${current_top_application_id}" ]]; then
            WARNING "Previously started Hilbert's application(s) detected: "
            ${DOCKER} ps -a --filter "label=is_top_app=1" --filter "label=com.docker.compose.project=${COMPOSE_PROJECT_NAME}"
        else
            DEBUG "No previously started applications are currently detected"
        fi
    fi

    if [[ "${hilbert_autostart,,}" = "false" ]]; then
        INFO "Auto-starting is not enabled pre station configuration"
        DEBUG "hilbert_autostart: ${hilbert_autostart} (true/false) (case insensitive!)"
#        DEBUG "hilbert_autostart_delay: ${hilbert_autostart_delay} (positive int)"

        DEBUG "Will NOT start Hilbert now!.."
        exit 0
    fi

    local start_application="${hilbert_station_default_application}"

    ## TODO: FIXME: check restart/crash policy!!!!!
    ## hilbert_restart_policy = "cleanup"?
    ## Cleanup any other containers: e.g. docker ps -aq | xargs --no-run-if-empty docker rm -f
    if [[ -n "${current_top_application_id}" ]]; then
        ## NOTE: restart policy: continue??
        if [[ -n "${APP_ID}" ]]; then
            start_application="${APP_ID}"
    #        cmd_docker_pause ${current_top_application_id}
    #      else
        fi

        INFO "Trying to kill (all) found Hilbert's TOP applications: ${current_top_application_id}..."
        cmd_docker_stop ${current_top_application_id}
    fi

    if [[ -n "${current_bg_servce_ids}" ]]; then
        INFO "Trying to kill (all) found Hilbert's BG services: ${current_bg_servce_ids}..."
        cmd_docker_stop ${current_bg_servce_ids}
    fi

#    DEBUG "Sleeping for [${hilbert_autostart_delay}] sec (due to 'hilbert_autostart_delay' from '${HILBERT_CONFIG_FILE}')..."
#    sleep "${hilbert_autostart_delay}"

    ## NOTE: Specific for GPU/OpenGL related apps:
    if [[ ! -f "${HILBERT_OGL}" ]]; then
        if [[ -f "${HILBERT_CONFIG_BASEDIR}/${OGL}" ]]; then
            cp -fp "${HILBERT_CONFIG_BASEDIR}/${OGL}" "${HILBERT_OGL}" || sudo -n -P cp -fp "${HILBERT_CONFIG_BASEDIR}/${OGL}" "${HILBERT_OGL}"
        fi
    fi

    if [[ ! -f "${HILBERT_OGL}" ]]; then
        WARNING "Missing '${HILBERT_OGL}'! Please regenerate and place to '${HILBERT_CONFIG_BASEDIR}'!"
    fi

    local indices=( ${!hilbert_station_profile_services[@]} )  # Array of indices
    local N=${#indices[@]}
    local data

    if [[ $N -ne 0 ]]; then
        local i
        local sv

        for ((i=0; i < $N; i++)) ; do
            sv="${hilbert_station_profile_services[indices[i]]}"
            data="$(_service_get_info "$sv")"
            if [[ $? -ne 0 ]]; then
                WARNING "Trying to start a bad service [${indices[i]}]: '${sv}'"
            else
                DEBUG "Starting Service $sv: [$data]"
            fi

            cmd_start_service "${sv}"

            if [[ $? -ne 0 ]]; then
                ERROR "Could not start service: '${sv}' ($data)"
            fi
        done
    else
        DEBUG "No services should be running on this station!"
    fi

    ## NOTE: start default application!
    if [[ -n "${start_application}" ]]; then
        ## NOTE: check whether ${start_application} is a valid ID:
        data="$(_service_get_info "${start_application}")"
        if [[ $? -ne 0 ]]; then
            ERROR "Trying to start a bad application: '${start_application}'"
        else
            DEBUG "Starting Default application: ${start_application} [$data]"
        fi

        if [[ -n "${APP_ID}" && "${start_application}" = "${APP_ID}" ]]; then
            # TODO: FIXME: same Application ID => same app!?? (same docker-compose.yml? same env.vars?) :-(
            cmd_start_service "${start_application}" #          cmd_restart_service "${APP_ID}"
        else
            cmd_start_service "${start_application}"
        fi

        if [[ $? -ne 0 ]]; then
            ERROR "Could not start application: '${start_application}' ($data)"
        fi
    else
        INFO "No default application: is this a server?!"
    fi
    return 0
}

## @fn cmd_stop stop current top application and background services
function cmd_stop() {
    cmd_native_autodetect
    cmd_read_configuration
    cmd_detect_top_application
    if [[ -n "${current_top_application_id}" ]]; then
        INFO "Previously started Hilbert's application(s) detected: [${current_top_application_id}, APP_ID: ${APP_ID}]"

        if [[ -z "${APP_ID}" ]]; then
            # ${DOCKER} ps -a --filter "label=is_top_app=1" --filter "label=com.docker.compose.project=${COMPOSE_PROJECT_NAME}"
            cmd_docker_stop ${current_top_application_id}
        else
            cmd_stop_service "${APP_ID}"
        fi
    else
        INFO "No previously started applications are currently detected"
    fi
    # Array of indices

    local indices=( ${!hilbert_station_profile_services[@]} )
    local N=${#indices[@]}

    if [[ $N -ne 0 ]]; then
        local i
        local sv

        for ((i=$N - 1; i >= 0; i--)) ; do
            sv="${hilbert_station_profile_services[indices[i]]}"
            data="$(_service_get_info "$sv")"
            if [[ $? -ne 0 ]]; then
                WARNING "Trying to stop a bad service [${indices[i]}]: '${sv}'"
            else
                DEBUG "Starting Service $sv: [$data]"
            fi

            cmd_stop_service "${sv}"

            if [[ $? -ne 0 ]]; then
                ERROR "Could not stop service: '${sv}' ($data)"
            fi
        done
    else
        DEBUG "No services should be running on this station!"
    fi
    return 0
}

## @fn cmd_shutdown
function cmd_shutdown() {
    local arg=$@
    DEBUG "Shutting this system down... Arguments: [${arg}]"

    if [[ -n "${DRY_RUN}" ]]; then
        echo "[${DRY_RUN}] Running: [${SHUTDOWN} ${arg} || sudo -n -P ${SHUTDOWN} ${arg}]..."
    else
        ${SHUTDOWN} ${arg} || sudo -n -P ${SHUTDOWN} ${arg}
    fi
}

## @fn cmd_subcommand_handle Main CLI parser/handler
function cmd_subcommand_handle() {
    subcommand=$1; shift

    DEBUG "Subcommand to handle: '$subcommand'"

    case "$subcommand" in
    list_applications)
        cmd_start_locking
        ## TODO: arguments?
        cmd_list_applications "$@"
        exit $?
        ;;
    list_services)
        cmd_start_locking
        ## TODO: arguments?
        cmd_list_services "$*"
        exit $?
        ;;
    init)
        cmd_start_locking
        cmd_init "$*"
        exit $?
        ;;
    app_change)
        cmd_start_locking
        cmd_app_change "$*"
        exit $?
        ;;
    stop)
        cmd_start_locking
        ## TODO: arguments?
        cmd_stop "$*"
        exit $?
        ;;
    shutdown)
        cmd_start_locking
        local arg="$*"
        if [[ "${arg}" = "now" || "${arg}" = "-r now" ]]; then
            cmd_shutdown "$@"
        else
            cmd_shutdown
        fi
        exit $?
        ;;
    start)
        cmd_start_locking
        ## TODO: arguments?
        cmd_start "$*"
        exit $?
        ;;
    cmd_*) ## NOTE: hidden subcommand-s (for testing)
        ## NOTE: lock to be sure...
        cmd_start_locking
        cmd_native_autodetect
        ${subcommand} "$*"

        if [[ $? -ne 0 ]]; then
            ERROR "Something went wrong in subcommand handler: [${subcommand} '$*']!"
            exit 1
        else
            DEBUG "Script successfully handled hidden subcommand: [${subcommand}]!"
            exit 0
        fi
        ;;
    esac

    if [[ -n "${subcommand}" ]]; then
        ERROR "Invalid sub-command: '$subcommand'"
        exit 1
    fi

    ## NOTE: "${subcommand}" == ""
    cmd_usage
    exit 0
}

shift $((OPTIND -1))
cmd_subcommand_handle "$@"
exit $?  ## NOTE: Just in case...
